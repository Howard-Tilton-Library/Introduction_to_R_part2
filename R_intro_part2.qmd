---
title: "Intro to Coding in R, Part II: Management, Processing & Analysis"
author: "Mike Ellis (he/him/his) <br> PhD Candidate <br> Ecology & Evolutionary Biology <br> Tulane University <br> mellis5@tulane.edu"
date: "`r format(Sys.time(), '%d %B %Y')`"

format: 
  html:
    toc: true
    toc-location: left
    toc-depth: 3
    number-sections: true
    number-depth: 1
    theme: lumen
    highlight-style: github
    code-overflow: wrap
    code-fold: false
    code-copy: true
    code-link: false
    code-tools: false
    code-block-border-left: "#0C3823"
    code-block-bg: "#eeeeee"
    fig-cap-location: margin
    linestretch: 1.25
    fontsize: "large"
    embed-resources: true

execute:
  echo: true
  keep-md: true
---

![](Data_In/Figures/TUL_Logos_narrow.png){fig-align="center"}

Welcome! This tutorial was commissioned by Tulane University's Howard-Tilton Memorial Library as the second half of an Intro to R workshop. It is targeted towards faculty, post-docs, graduate students, and undergraduates new to R. In part I, you learned the fundamentals of R and built a foundation for working with your own data. In this second installment, you'll learn to streamline project management, incorporate packages to increase functionality, code more efficiently in the "tidy" dialect, implement more complex conditional and iterative processes, summarize and analyze your data, and visualize your results with figures.

Happy coding!

<br>

# **Projects**

## Create your first project

**Projects** are convenient places to store all of the files associated with whatever it is you're working on in *RStudio*. Bundling up files in projects tends to improve your organizational efficiency, and it streamlines the normal, everyday hassle of importing data and exporting product. Projects are also easily shared with collaborators and save them the headache of replacing your local file paths with their local file paths.

::: callout-tip
## <font size="5"> Try it </font>

<font size="4"> Create a new project to manage materials for this tutorial. </font>
:::

-   *RStudio* Really encourages you to use projects, giving you three easy options to start one. Simply choose "New Project..." from the File drop-down menu, or click one of these two buttons:

![Click one of these to start a new project!](Data_In/Figures/new_projects.png)

-   When creating a new project, you have the option of putting it in a pre-existing folder, in which case it will take the name of that folder, or creating a new folder with the same project name. (You may also see an option to start a new project with version control, which is a more advanced feature beyond the scope of this tutorial).

::: callout-note
## <font size="5"> Note </font>

<font size="4"> This is more advanced, but if you're active on GitHub or hope to be someday, then you'll come to love R projects for smoothly translating to GitHub repositories and vice versa! </font>
:::

-   Choose "New Directory" and then "New Project" to create a folder/project somewhere that makes sense for you. Give it a meaningful but short name like "Intro_to_R\_part2". Don't check any of the optional boxes for now.

-   I recommend keeping your R project folders as organized as possible so you can navigate quickly and share clean work spaces with collaborators since sharing science often means sharing scripts, data, and R output like figures. You may want to consider adding some sub-folders to your project Here's what my setup looks like for this lesson (and most of my R projects):

![An example of clean project organization](Data_In/Figures/project_organization.png)

-   Now that you've created a project, you can always access it using the Project drop-down menu in the right side of *RStudio*. The menu will display the currently open/active project. Check to make sure your project for this tutorial is open to ensure functionality of upcoming code.

-   You can directly access files and folders in your open project through the Files tab in *RStudio*. Very convenient!

## Add R script to project

Great! Now that you've got a project up and running, start a new R script for this tutorial. You can do so using the New File button in the top left, the File drop-down menu, or -- a new option -- the "New Blank File" drop-down menu under your Files tab.

![Add and name a new R script to your project.](Data_In/Figures/new_script.png)

## Add data to project, import

We'll need some data to work on for this tutorial. Let's use the data we created in Part I of this tutorial. If you don't have it handy, you can download it directly from the web using `download.file()`.

When you're working in a Project, R automatically sets it as your working directory! That means you don't have to type out the entire path to access your project folder or the files therein.

::: callout-tip
## <font size="5"> Try it </font>

<font size="4"> Enter the following code into your new script to download data from the web and directly into your project directory. Then, import it. </font>
:::

```{r}
#| label: data-download
#| eval: false

# Setup ----

# First, take a quick look at the help file for download.file()
?download.file

# NOTE: download.file() takes several arguments. We're most concerned with the url, or address of the hosted file for download, and "destfile", or the destination and name you'd like to give the downloaded file.

# NOTE: All of these arguments are text strings and therefore belong in quotations.

# NOTE: You MUST provide a file type in your desired file name (in this case, .csv).
```

You may need to slightly alter the `destfile =` argument depending on whether or not you'd like to store these data in a project sub-folder.

```{r}
#| label: data-download2
#| eval: false

# I have a sub-folder in my project called "Data_In" and therefore need to specify that location before my chosen file name.
download.file(url = "https://libguides.tulane.edu/ld.php?content_id=71000172", destfile = "Data_In/intro2_bird_data.csv")

# If you don't have a similar sub-folder, you only need to provide destfile with a file name. It will automatically save to your project folder.
download.file("https://libguides.tulane.edu/ld.php?content_id=71000172", "intro2_bird_data.csv")
```

These data should now appear in your *RStudio* files pane. Let's go ahead and import them.

```{r}
#| label: import

# Importing data
# Remember to insert or drop a sub-folder as needed.
# This code says "I will create an object named `birds` and assign to it the data contained in the following .csv file stored in my project or specified project sub-folder."
birds <- read.csv("Data_In/intro2_bird_data.csv")
```

Don't forget to scope out your data after importing! I'd recommend entering `View()` into your console. And remember, you've also got...

```{r}
#| label: inspect
#| eval: false

head(birds)
tail(birds)
str(birds)
```

# **Packages**

In this tutorial, we're going to do some more complex data munging and analyses requiring specialized functions not included in base *R*. **Packages**, or **Libraries**, are open-source bundles of pre-coded functions (and oftentimes data) that we can install and access in *RStudio* to suit our own needs.

One of the most popular *R* packages is called `tidyverse`. It's actually a collection of packages geared towards making your life *much* easier...at least when it comes to data work. To access it, you need to install it (once) and then load it (once per session when re-opening *RStudio*).

## Installing

::: callout-tip
## <font size="5"> Try it </font>

<font size="4"> Install and load `tidyverse` packages, also known as libraries. </font>
:::

You can view all the packages in base *R* and all the packages you've ever installed by clicking the Packages tab in the *RStudio* pane including your Files and Plots tabs. Do so now, and underneath the tab names, you'll see buttons to Install and Update packages.

::: callout-warning
## <font size="5"> Are you online? </font>

<font size="4"> Most packages are hosted online by *CRAN, The Comprehensive R Archive Network*, so naturally you'll need an internet connection to download and install them! </font>
:::

Click that "Install" button at the top of the pane, type in `tidyverse` in the Packages bar, make sure the "Install Dependencies" box is **checked**, and select the "Install" option in the pop-up window. (For most users, the default library path to install to is a perfectly good option). *RStudio* will then take care of the rest, showing you its progress in your Console pane.

![You should see something like this when installing tidyverse.](Data_In/Figures/install.png){width="811"}

::: callout-note
## <font size="5"> Note </font>

<font size="4"> Packages are occasionally updated by their creators, often to maintain functionality when *R* or *RStudio* are updated. As a result, you'll have to update your software and/or packages every now and then. When the time comes, you'll typically get warnings from *RStudio* while loading or installing new packages. You can use the Update button at the top of the Packages tab to take care of business. </font>
:::

## Loading

The nice thing about installing packages is that you generally only have to do it once. To *access*, a package, however, you have to tell *RStudio* to open it every time you start a new session. Fortunately, that's quick and easy too. All you have to do is plug the desired package into the `library()` function.

::: callout-note
## <font size="5"> Note </font>

<font size="4"> It's good practice to put code to load libraries, aka packages, in the very beginning of your *script*, not your console! Loading all your required packages up front, not buried halfway through your document can save you and your collaborators from package conflicts down the road. </font>
:::

```{r}
#| label: library

# Running library(tidyverse) allows you to access data and functions from the collection of packages that make up the tidyverse.
# Put this somewhere near the top of your script in your Setup section.
library(tidyverse)
```

See those Conflict messages? Those show up because different package creators sometimes use the same word when naming functions with different applications. When calling a function with a conflicting name, e.g., `filter()`, *RStudio* will automatically use the version of the function from the most recently loaded library, in this case `dplyr`, which is part of `tidyverse`. If you want to use a different version of the function in your script, you can specify it by putting the package name in front of two colons and the function title, e.g., `stats::filter(your_data_here)` will override `filter(your_data_here)` from the `dplyr` package after loading `tidyverse`.

# **Welcome to the Tidyverse**

## About

Great! You can now use the `tidyverse` to create and process "tidy" data, which boils down to making sure your data are organized with one value per cell and one cell per column and row. Storing your data this way greatly streamlines munging and analysis workflows.

The `tidyverse` has a lot of strengths over base *R*. The most obvious of which that you can benefit from almost immediately are that it...

1.    reduces repetitive wordiness (like constantly having to supply your data and your data$column names) while...
2.    simultaneously targeting user-specified data in dynamically moving data sets.
3.    And on top of that, it allows you to quickly and clearly string together functions in an obvious order without having to constantly create and reference new objects or wrap 10 functions inside of one another! More on this in the **pipes** section below.

Here are the `tidyverse` packages you now have access to and their basic purposes. When you're working with your own data and come across a complex roadblock, see if your situation can be solved by the tools in one of these packages:

-   `tidyr`
    -   Tools for reshaping your data to make it tidy. Too many values in a cell? Should your rows be columns or vice versa? This is how you get your data to where it needs to be for analysis.
-   `dplyr`
    -   Common data manipulation tools for making changes to a single data set and/or comparing and combining multiple data sets.
-   `stringr`
    -   A great toolbox for working with strings, aka non-numeric character data. Find, replace, mutate, subset, combine/separate and more.
-   `ggplot2`
    -   The gold standard for creating beautiful plots and figures in *R*.
-   `purrr`
    -   Powerful tools for applying functions to multiple vectors, columns, or lists of data at once.
-   `forcats`
    -   Tools for working with **factor** variables, i.e., categorical data like treatment or forest type.
-   `tibble`
    -   Functions for working with **tibbles**, which are what the `tidyverse` calls its new and improved versions of data frames. They're largely interchangeable and conversions happen behind the scenes, so you generally don't need to worry about it. If you see tibble, think data frame.
-   `readr`
    -   For importing tabular data in more exotic or complicated formats.

::: callout-note
## <font size="5"> Note </font>

<font size="4"> To learn more about tidy data and the `tidyverse`, explore the resources available at <https://www.tidyverse.org/learn/> and the [RStudio cheatsheets](https://posit.co/resources/cheatsheets/?type=posit-cheatsheets&_page=2/) for `tidyverse` packages. </font>
:::

## Popular `tidyverse` functions

`tidyverse` functions work pretty much the same as functions from base *R*. Supply a function with data, feed it any necessary arguments, and put the result into a container object:

`object -> my.function(data, argument = desired_manipulation)`

Below we'll create a smaller data frame to test functions on, making sure not to overwrite it (meaning don't set it equal to anything with `<-`). This way, changes we make aren't stored and we can continue to manipulate the smaller test object, getting expected -- but *temporary* -- results every time.

::: callout-tip
## <font size="5"> Try it </font>

<font size="4"> Familiarize yourself with some of the most common and useful functions in the `tidyverse`. </font>
:::

### `select()`

A useful function and removing or reordering columns by name. Specifying column names rather than column number ensures you select the right data even when columns switch places.

```{r}
#| label: select

### Tidyverse functions ----

# Before we begin, let's save a smaller data set to practice with using what we learned in Intro to R, part I
small_birds <- birds[c(1:2, 12:13, 22:23),]

# Next, remind yourself of the column names and their order
colnames(small_birds)

# select() allows you to select columns to keep.
# You can also reorder them at the same time.
# Here we select three columns from the birds data frame, moving family before species: 
select(small_birds, family, species, mass_g)

# You can also specify columns to remove by putting a minus or hyphen in front of their names
select(small_birds, -species, -family)

# Combining with c() to remove a list of columns
select(small_birds, -c(family, mass_g, mass_to_wing))

# NOTE: There are several additional ways to select columns based on things like column class and starting letter. See the help section for more.
```

### `arrange()`

This function can be used to sort your data alphabetically or numerically

```{r}
#| label: arrange

# Arranging by wing_length_mm
arrange(small_birds, wing_length_mm)

# Notice that arrange sorted by ascending order.
# Wrap your column name in the desc() function to sort from largest to smallest
arrange(small_birds, desc(wing_length_mm))

# It works the same with character class columns
arrange(small_birds, desc(species))

# And you can sort by multiple columns, too.
# For example, you could sort alphabetically by species name first and then by largest to smallest wing length for each species.
arrange(small_birds, species, desc(wing_length_mm))

```

### `rename()`

A quick and easy way to rename your columns.

```{r}
#| label: rename

# Here we'll temporarily rename our column names. It's temporary because we haven't overwritten our object with <-
# NOTE: In your arguments, new name must precede old name. It won't work if you put the old name before the new name.
rename(small_birds, wing = wing_length_mm, weight = mass_g)

```

### `mutate()`

A broad method to "create, modify, and delete columns". This is one of the most important functions in the `tidyverse`. When you start making permanent changes to your data, you'll likely use this one a lot.

```{r}
#| label: mutate

# You can use mutate to create new columns using existing columns.
# They'll get tacked on to the end of your data frame.
# Just create a new column name and set it equal to whatever you want. Here, we'll convert wing length in mm to cm.
mutate(small_birds, wing_cm = wing_length_mm / 10)

# Or you can alter existing columns by setting them equal to an altered version of themselves.
# Here, we'll set replace the family column by setting it equal to a capitalized version of itself.
mutate(small_birds, family = str_to_upper(family))
# NOTE: str_to_upper() is also part of the tidyverse! it comes from the stringr package.

# You can also remove columns by setting them equal to NULL, which has the same effect as using select(-column_name)
mutate(small_birds, family = NULL)

```

### `separate()`

A common problem with untidy data is too many values per cell. `separate()` is one function to break down a very simple multi-value cell into its component parts, but there are many more options for more complex situations in `tidyr` to look into if needed. The inverse of `separate()` is `unite()`.

```{r}
#| label: separate

# In this scenario, we want to break up the species column into its component parts assigning one word to each column. Conveniently for us, there are currently two words in each row of the "species" column, so this will be straightforward.
# Name the data you'd like to alter, specify the column (species), then name the new columns you'd like to separate species into, then define the separating character (there's a single space between American and next word, so that's a natural separator to pick).
separate(small_birds, species, into = c("Descriptor", "Bird"), sep = " ")
```

### `filter()` (bonus `str_detect()`)

This function is nearly identical to `subset()`, a base *R* function you saw in part I that allows you to reduce your data set down to just those rows meeting a specified criteria. The biggest difference is that `filter()`, as part of the `tidyverse`, can be strung together with other `tidyverse` functions. You'll see examples of this coming up next in the pipes section.

```{r}
#| label: filter
#| eval: false

# filter() works the same way as subset().
# Here are some easy examples
filter(small_birds, species != "American Crow")
filter(small_birds, mass_g >= 110)
```

```{r}
#| label: filter2
#| ref.label: filter
#| echo: false
```

Okay, here's a more complex example where we return only species names that contain the letters "ro" by combining `filter()` with `str_detect()`, another tidyverse function.

```{r}
#| label: str-detect

# This should return Crows and Robins, but notice that the "r" is capitalized in Robin and not Crow.
# str_detect() is sensitive to capitalization, so before we search for the "ro" string, we can convert all letters in the species column to lowercase using str_to_lower(). 
filter(small_birds, str_detect(str_to_lower(species), "ro"))
```


## Pipes (Are the Best)

Finally! We've made it to the pipes!

### `case_match()`

This function allows you to replace matching values in a column while leaving the rest unchanged.

```{r}
#| label: case-match

# Here we'll replace all common names with their scientific names
small_birds %>% 
  mutate(species = case_match(species, 
                              "American Kestrel" ~ "F. sparverius",
                              "American Crow" ~ "C. brachyrhynchos",
                              "American Robin" ~ "T. migratorius"))

# If you don't want to replace all values, you can set non-target values to their existing, default value.
# You can replace multiple values with a single value, too.
small_birds %>%
  mutate(species = case_match(species,
                             c("American Kestrel", 
                               "American Robin") ~ "Not A Crow",
                             .default = species))

# It works with numbers, too!
small_birds %>%
  mutate(mass_to_wing = case_match(mass_to_wing,
                                   0.62 ~ 0.65,
                                   .default = mass_to_wing))

```

# **Relational Joins**

# **Grouping & Summarizing Data**

## `group_by()`

-   example with count or something

## `summarize()`

-   n(), mean(), sd(), min(), max()

# **If/Else Statements**

# **For Loops**

# **T-Tests**

# **Figures in R**

-   r-graphs-gallery
-   ggplot
-   Alternative to boxplots
-   Bar chart
-   Saving/Exporting
